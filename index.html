<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ë–æ–º–±–µ—Ä–º–µ–Ω: AI –ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e293b;
            --grid-color: #334155;
        }
        /* –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∂–µ—Å—Ç–æ–≤ */
        * {
            touch-action: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100dvh;
        }

        .pixel-font { font-family: 'Press Start 2P', cursive; }

        /* Main Layout */
        main {
            flex-grow: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            position: relative;
        }

        #game-container {
            position: relative;
            height: 100%;
            width: auto;
            max-width: 100%;
            aspect-ratio: 1 / 1;
            background-color: var(--grid-color);
            border: 4px solid #475569;
            border-radius: 4px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            margin: auto;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            grid-template-rows: repeat(13, 1fr);
            width: 100%;
            height: 100%;
        }

        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(10px, 4vmin, 24px);
            position: relative;
        }

        /* Entities */
        .player { z-index: 30; transition: transform 0.1s linear; }
        .enemy { z-index: 25; animation: bounce 1s infinite; }
        .bomb { z-index: 20; animation: pulse 0.5s infinite alternate; }
        .item { z-index: 10; }
        
        .danger-zone { background-color: rgba(239, 68, 68, 0.3) !important; }
        .explosion { background-color: rgba(239, 68, 68, 0.9) !important; z-index: 28; }
        .explosion::after { content: 'üí•'; font-size: 80%; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5%); } }
        @keyframes pulse { from { transform: scale(0.9); } to { transform: scale(1.1); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Controls Footer */
        #controls-area {
            flex-shrink: 0;
            background: rgba(15, 23, 42, 0.95);
            border-top: 2px solid #334155;
            padding-bottom: env(safe-area-inset-bottom, 10px);
            padding-top: 10px;
            z-index: 40;
            position: relative;
        }

        .btn-control {
            background: #3b82f6;
            border-bottom: 4px solid #1d4ed8;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
        }
        .btn-control.pressed { transform: translateY(4px); border-bottom: 0; background: #2563eb; }
        
        .btn-bomb { background: #ef4444; border-bottom: 4px solid #b91c1c; border-radius: 50%; font-size: 28px; }
        .btn-bomb.pressed { background: #dc2626; }

        /* Overlays */
        .level-overlay {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            padding: 20px;
        }
        #toast { z-index: 100; transition: opacity 0.3s; }
        
        .spinner {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 2px solid #fff;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        /* –ù–û–ú–ï–† –í–ï–†–°–ò–ò */
        #version-tag {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px #000000;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
            z-index: 100;
        }

        /* –ë–µ–π–¥–∂ —Ä–µ–∂–∏–º–∞ (Telegram / Standalone) */
        #mode-badge {
            position: absolute;
            bottom: 5px;
            left: 8px;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.8);
            color: #e5e7eb;
            font-family: 'Roboto', sans-serif;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- HEADER -->
    <header class="flex-none flex justify-between items-center p-2 bg-slate-900 border-b border-slate-700 shadow-md z-30">
        <div class="flex items-center gap-2 text-[10px] sm:text-xs">
            <div class="flex flex-col">
                <span class="text-gray-400 uppercase">LVL</span>
                <span id="level-el" class="pixel-font text-purple-400">1</span>
            </div>
            <div class="flex flex-col">
                <span class="text-gray-400 uppercase">HP</span>
                <span id="lives-el" class="pixel-font text-red-400">1</span>
            </div>
            <div class="flex flex-col">
                <span class="text-gray-400 uppercase">KEY</span>
                <span id="key-el" class="pixel-font text-gray-500">‚ùå</span>
            </div>
            <div class="flex flex-col">
                <span class="text-gray-400 uppercase">BOMB</span>
                <span id="bombs-el" class="pixel-font text-yellow-400">1</span>
            </div>
            <!-- SCORE -->
            <div class="flex flex-col">
                <span class="text-gray-400 uppercase">SCORE</span>
                <span id="score-el" class="pixel-font text-amber-300">0</span>
            </div>
        </div>
        <div class="flex gap-1 overflow-x-auto">
            <button id="ai-map-btn" class="bg-emerald-600 px-2 py-1 rounded font-bold text-[10px] shadow-lg active:scale-95 transition whitespace-nowrap flex items-center gap-1">
                üèóÔ∏è –ö–∞—Ä—Ç–∞
            </button>
            <button id="ai-theme-btn" class="bg-pink-600 px-2 py-1 rounded font-bold text-[10px] shadow-lg active:scale-95 transition whitespace-nowrap flex items-center gap-1">
                üé® –¢–µ–º–∞
            </button>
            <button id="ai-btn" class="bg-indigo-600 px-2 py-1 rounded font-bold text-[10px] shadow-lg active:scale-95 transition whitespace-nowrap flex items-center gap-1">
                ‚ú® –°–æ–≤–µ—Ç
            </button>
        </div>
    </header>

    <!-- MAIN -->
    <main>
        <div id="game-container">
            <div id="game-board"></div>
            
            <!-- Overlays -->
            <div id="overlay" class="level-overlay absolute inset-0 hidden flex-col items-center justify-center z-50 text-center">
                <h1 id="overlay-title" class="pixel-font text-xl sm:text-3xl text-white mb-4"></h1>
                <p id="overlay-msg" class="text-gray-300 mb-4 text-xs sm:text-base max-w-xs mx-auto"></p>
                <div id="overlay-ai-comment" class="text-yellow-400 text-[10px] sm:text-xs italic mb-6 max-w-xs mx-auto min-h-[20px]"></div>
                <button id="overlay-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full text-sm sm:text-lg shadow-lg transform transition hover:scale-105">
                    –î–ê–õ–ï–ï
                </button>
            </div>

            <!-- Badge —Ä–µ–∂–∏–º–∞ -->
            <div id="mode-badge">Standalone</div>
        </div>
    </main>

    <!-- CONTROLS -->
    <footer id="controls-area">
        <div class="max-w-md mx-auto px-4 flex justify-between items-end gap-2 h-[160px]">
            <!-- D-PAD -->
            <div class="grid grid-cols-3 gap-1 w-36 h-36 pb-2">
                <div></div>
                <button class="btn-control h-full w-full" data-key="ArrowUp">‚¨ÜÔ∏è</button>
                <div></div>
                <button class="btn-control h-full w-full" data-key="ArrowLeft">‚¨ÖÔ∏è</button>
                <div class="flex items-center justify-center text-gray-600 opacity-30 text-xl">‚úö</div>
                <button class="btn-control h-full w-full" data-key="ArrowRight">‚û°Ô∏è</button>
                <div></div>
                <button class="btn-control h-full w-full" data-key="ArrowDown">‚¨áÔ∏è</button>
                <div></div>
            </div>
            <!-- ACTION -->
            <div class="flex flex-col items-center gap-1 mb-4">
                <button class="btn-control btn-bomb w-20 h-20 shadow-xl" data-key="Space">üí£</button>
            </div>
        </div>
        <!-- –ù–û–ú–ï–† –í–ï–†–°–ò–ò -->
        <div id="version-tag">v1.6</div>
    </footer>

    <div id="toast" class="fixed top-16 left-1/2 -translate-x-1/2 bg-slate-800 border border-yellow-500 text-yellow-100 px-4 py-2 rounded-lg shadow-2xl opacity-0 pointer-events-none text-xs sm:text-sm text-center w-max max-w-[90%]">
        <span id="toast-msg"></span>
    </div>

    <script>
        /* --- TELEGRAM INIT --- */
        let tg = null;
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                const wa = window.Telegram.WebApp;
                // —Å—á–∏—Ç–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–º WebApp —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å initData/initDataUnsafe
                const hasInitData = (wa.initData && wa.initData.length > 0) ||
                                    (wa.initDataUnsafe && Object.keys(wa.initDataUnsafe).length > 0);
                if (hasInitData) {
                    tg = wa;
                    tg.expand();
                    tg.ready();
                }
            }
        } catch (e) {
            tg = null;
        }

        const modeBadge = document.getElementById('mode-badge');
        if (tg) {
            modeBadge.textContent = 'Telegram ¬∑ —Ä–µ–π—Ç–∏–Ω–≥ @Games_trivia_bot';
        } else {
            modeBadge.textContent = 'Standalone ¬∑ –±–µ–∑ —Ä–µ–π—Ç–∏–Ω–≥–∞';
        }

        /* --- CONSTANTS --- */
        const GRID_SIZE = 13;
        const SOFT_WALL_DENSITY = 0.45;
        const PLAYER_SPEED_MS = 160;
        const apiKey = ""; // API Key –¥–ª—è Gemini, –µ—Å–ª–∏ –Ω—É–∂–µ–Ω

        const GAME_ID = "bomberman_ai_architect";
        const GAME_NAME = "–ë–æ–º–±–µ—Ä–º–µ–Ω: AI –ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä";
        
        /* --- ASSETS (Default) --- */
        let SPRITES = {
            EMPTY: '', HARD_WALL: 'üß±', SOFT_WALL: 'üå≤', PLAYER: 'üòé',
            ENEMY: 'üëª', BOMB: 'üí£', RANGE_UP: '‚ö°', EXTRA_LIFE: '‚ù§Ô∏è', EXTRA_BOMB: 'üß®',
            KEY: 'üîë', DOOR: 'üö™', DEAD: 'üíÄ'
        };

        /* --- STATE --- */
        let board = [];
        let hiddenItems = [];
        let gameState = {
            level: 1,
            player: { x: 1, y: 1, range: 1, lives: 2, maxBombs: 1, activeBombs: 0, hasKey: false },
            enemies: [],
            bombs: [],
            isOver: false,
            isPaused: false,
            score: 0,
            runId: Date.now(),
            levelStartTime: Date.now(),
            lastEnemyMove: 0,
            stats: {
                enemiesKilled: 0,
                hitsTaken: 0,
                bombsPlaced: 0,
                levelsCompleted: 0
            }
        };
        
        // INPUT STATE
        let activeInput = { key: null, isDown: false, lastMoveTime: 0 };

        let gameLoopId;
        let animationFrameId;

        /* --- DOM --- */
        const boardEl = document.getElementById('game-board');
        const levelEl = document.getElementById('level-el');
        const livesEl = document.getElementById('lives-el');
        const keyEl = document.getElementById('key-el');
        const bombsEl = document.getElementById('bombs-el');
        const scoreEl = document.getElementById('score-el');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMsg = document.getElementById('overlay-msg');
        const overlayBtn = document.getElementById('overlay-btn');
        const overlayAi = document.getElementById('overlay-ai-comment');

        /* --- GAME LIFECYCLE --- */
        function startGame(reset = false) {
            if (reset) {
                gameState.level = 1;
                gameState.player = { x: 1, y: 1, range: 1, lives: 3, maxBombs: 1, activeBombs: 0, hasKey: false };
                gameState.score = 0;
                gameState.runId = Date.now();
                gameState.stats = {
                    enemiesKilled: 0,
                    hitsTaken: 0,
                    bombsPlaced: 0,
                    levelsCompleted: 0
                };
            } else {
                gameState.player.x = 1;
                gameState.player.y = 1;
                gameState.player.activeBombs = 0;
                gameState.player.hasKey = false;
            }
            
            gameState.enemies = [];
            gameState.bombs = [];
            gameState.isOver = false;
            gameState.isPaused = false;
            gameState.levelStartTime = Date.now();
            gameState.lastEnemyMove = 0;
            
            activeInput.key = null;
            activeInput.isDown = false;

            overlay.classList.add('hidden');
            overlay.classList.remove('flex');
            
            initLevel();
        }

        function initLevel(customGrid = null) {
            if (gameLoopId) clearInterval(gameLoopId);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            generateMap(customGrid);
            spawnEnemies(Math.min(gameState.level + 1, 8));
            generateLevelBriefing();

            gameLoopId = setInterval(gameTick, 50);
            animationFrameId = requestAnimationFrame(renderLoop);
            updateUI();
        }

        function gameTick() {
            if (gameState.isOver || gameState.isPaused) return;
            processInput();
            
            const now = Date.now();
            if (!gameState.lastEnemyMove || now - gameState.lastEnemyMove > Math.max(300, 800 - (gameState.level * 40))) {
                moveEnemies();
                gameState.lastEnemyMove = now;
            }
            checkCollisions();
        }

        function renderLoop() {
            render();
            animationFrameId = requestAnimationFrame(renderLoop);
        }

        /* --- INPUT --- */
        function processInput() {
            if (!activeInput.isDown || !activeInput.key) return;
            const now = Date.now();
            if (now - activeInput.lastMoveTime < PLAYER_SPEED_MS) return;

            let dx = 0, dy = 0;
            const key = activeInput.key;
            if (key === 'ArrowUp') dy = -1;
            else if (key === 'ArrowDown') dy = 1;
            else if (key === 'ArrowLeft') dx = -1;
            else if (key === 'ArrowRight') dx = 1;

            if (dx !== 0 || dy !== 0) {
                movePlayer(dx, dy);
                activeInput.lastMoveTime = now;
            }
        }

        function setInput(key, isDown) {
            if (key === 'Space') {
                if (isDown && !gameState.isOver && !gameState.isPaused) placeBomb();
                return;
            }
            if (isDown) {
                activeInput.key = key;
                activeInput.isDown = true;
            } else {
                if (activeInput.key === key) {
                    activeInput.isDown = false;
                    activeInput.key = null;
                }
            }
        }

        /* --- MAP LOGIC --- */
        function generateMap(customGrid = null) {
            boardEl.innerHTML = '';
            board = [];
            hiddenItems = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            let softWallCoords = [];

            if (customGrid) {
                // Use AI provided grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const char = customGrid[y][x];
                        if (char === '#') row.push(SPRITES.HARD_WALL);
                        else if (char === 'T') {
                            row.push(SPRITES.SOFT_WALL);
                            softWallCoords.push({x, y});
                        }
                        else row.push(SPRITES.EMPTY);
                    }
                    board.push(row);
                }
            } else {
                // Standard Procedural Generation
                for (let y = 0; y < GRID_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1 || (x % 2 === 0 && y % 2 === 0)) {
                            row.push(SPRITES.HARD_WALL);
                        } else {
                            if ((x < 3 && y < 3)) {
                                row.push(SPRITES.EMPTY);
                            } else {
                                if (Math.random() < SOFT_WALL_DENSITY) {
                                    row.push(SPRITES.SOFT_WALL);
                                    softWallCoords.push({x, y});
                                } else {
                                    row.push(SPRITES.EMPTY);
                                }
                            }
                        }
                    }
                    board.push(row);
                }
            }

            // Place Items
            softWallCoords.sort(() => Math.random() - 0.5);
            const placeItem = (item) => {
                if (softWallCoords.length > 0) {
                    const p = softWallCoords.pop();
                    hiddenItems[p.y][p.x] = item;
                }
            };

            placeItem(SPRITES.DOOR);
            placeItem(SPRITES.KEY);
            placeItem(SPRITES.RANGE_UP);
            placeItem(SPRITES.EXTRA_BOMB);
            if (Math.random() > 0.5) placeItem(SPRITES.EXTRA_LIFE);

            // DOM Init
            board.forEach((row, y) => {
                row.forEach((c, x) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `c-${x}-${y}`;
                    if (c === SPRITES.HARD_WALL) cell.style.backgroundColor = 'rgba(0,0,0,0.2)';
                    else if (c === SPRITES.SOFT_WALL) cell.style.backgroundColor = 'rgba(0,0,0,0.1)';
                    boardEl.appendChild(cell);
                });
            });
            
            // Force player safe zone if AI made walls there
            board[1][1] = SPRITES.EMPTY;
            board[1][2] = SPRITES.EMPTY;
            board[2][1] = SPRITES.EMPTY;
        }

        function spawnEnemies(count) {
            gameState.enemies = [];
            let spawned = 0, attempts = 0;
            while (spawned < count && attempts < 200) {
                attempts++;
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                if (board[y][x] === SPRITES.EMPTY && (x > 4 || y > 4)) {
                    gameState.enemies.push({ x, y });
                    spawned++;
                }
            }
        }

        /* --- GAME ACTIONS --- */
        function movePlayer(dx, dy) {
            const nx = gameState.player.x + dx;
            const ny = gameState.player.y + dy;
            const tile = board[ny][nx];
            
            if (tile === SPRITES.HARD_WALL || tile === SPRITES.SOFT_WALL) return;
            if (gameState.bombs.some(b => b.x === nx && b.y === ny)) return;

            gameState.player.x = nx;
            gameState.player.y = ny;

            if (tile === SPRITES.RANGE_UP) { 
                gameState.player.range++; 
                board[ny][nx] = SPRITES.EMPTY; 
                gameState.score += 20;
                showToast("‚ö° –†–∞–¥–∏—É—Å++ (+20)");
            }
            else if (tile === SPRITES.EXTRA_LIFE) { 
                gameState.player.lives++; 
                board[ny][nx] = SPRITES.EMPTY; 
                gameState.score += 50;
                showToast("‚ù§Ô∏è –ñ–∏–∑–Ω—å++ (+50)");
            }
            else if (tile === SPRITES.EXTRA_BOMB) { 
                gameState.player.maxBombs++; 
                board[ny][nx] = SPRITES.EMPTY; 
                gameState.score += 30;
                showToast("üß® –ë–æ–º–±++ (+30)");
            }
            else if (tile === SPRITES.KEY) { 
                gameState.player.hasKey = true; 
                board[ny][nx] = SPRITES.EMPTY; 
                gameState.score += 80;
                showToast("üîë –ö–ª—é—á! (+80)");
            }
            else if (tile === SPRITES.DOOR) {
                checkLevelComplete();
            }
            
            updateUI();
        }

        function moveEnemies() {
            gameState.enemies.forEach(enemy => {
                const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                const validMoves = dirs.filter(d => {
                    const tx = enemy.x + d.x, ty = enemy.y + d.y;
                    const tTile = board[ty][tx];
                    const passable = tTile === SPRITES.EMPTY || tTile === SPRITES.KEY || tTile === SPRITES.RANGE_UP || tTile === SPRITES.EXTRA_LIFE || tTile === SPRITES.EXTRA_BOMB;
                    const tBomb = gameState.bombs.find(b => b.x === tx && b.y === ty);
                    return passable && !tBomb;
                });
                if (validMoves.length > 0) {
                    const m = validMoves[Math.floor(Math.random() * validMoves.length)];
                    enemy.x += m.x;
                    enemy.y += m.y;
                }
            });
        }

        function placeBomb() {
            if (gameState.player.activeBombs >= gameState.player.maxBombs) return;
            if (gameState.bombs.some(b => b.x === gameState.player.x && b.y === gameState.player.y)) return;
            
            const bomb = { x: gameState.player.x, y: gameState.player.y, range: gameState.player.range };
            gameState.bombs.push(bomb);
            gameState.player.activeBombs++;
            gameState.stats.bombsPlaced++;
            render();
            setTimeout(() => explode(bomb), 2000);
        }

        function explode(bomb) {
            if (gameState.isOver) return;

            // –£–±–∏—Ä–∞–µ–º –±–æ–º–±—É
            gameState.bombs = gameState.bombs.filter(b => b !== bomb);
            gameState.player.activeBombs = Math.max(0, gameState.player.activeBombs - 1);
            
            let hitCells = [{x: bomb.x, y: bomb.y}];
            const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];

            dirs.forEach(d => {
                for(let i=1; i<=bomb.range; i++) {
                    const tx = bomb.x + d.x * i, ty = bomb.y + d.y * i;
                    if (tx<0||tx>=GRID_SIZE||ty<0||ty>=GRID_SIZE) break;
                    const tile = board[ty][tx];
                    if (tile === SPRITES.HARD_WALL) break;
                    hitCells.push({x: tx, y: ty});
                    if (tile === SPRITES.SOFT_WALL) {
                        const hidden = hiddenItems[ty][tx];
                        board[ty][tx] = hidden ? hidden : SPRITES.EMPTY;
                        hiddenItems[ty][tx] = null;
                        break;
                    }
                    if (tile === SPRITES.DOOR || tile === SPRITES.KEY) break;
                }
            });

            const beforeEnemies = gameState.enemies.length;

            hitCells.forEach(pos => {
                const cell = document.getElementById(`c-${pos.x}-${pos.y}`);
                if(cell) {
                    cell.classList.add('explosion');
                    setTimeout(() => cell.classList.remove('explosion'), 500);
                }
                if (pos.x === gameState.player.x && pos.y === gameState.player.y) takeDamage("blown_up");
            });

            // –£–±–∏—Ä–∞–µ–º –≤—Ä–∞–≥–æ–≤, –ø–æ–ø–∞–≤—à–∏—Ö –≤–æ –≤–∑—Ä—ã–≤
            gameState.enemies = gameState.enemies.filter(
                e => !hitCells.some(pos => pos.x === e.x && pos.y === e.y)
            );

            const killed = beforeEnemies - gameState.enemies.length;
            if (killed > 0) {
                const bonus = killed * 100;
                gameState.score += bonus;
                gameState.stats.enemiesKilled += killed;
                showToast(`‚ò†Ô∏è -${killed} –≤—Ä–∞–≥(–æ–≤) (+${bonus})`);
            }

            updateUI();
        }

        function takeDamage(cause) {
            if (gameState.isOver) return;
            gameState.player.lives--;
            gameState.stats.hitsTaken++;
            gameState.score = Math.max(0, gameState.score - 30);
            updateUI();
            if (gameState.player.lives <= 0) showGameOver(false, cause);
            else showToast("üíî –†–∞–Ω–µ–Ω! (-30)");
        }

        function checkCollisions() {
            if (gameState.enemies.some(e => e.x === gameState.player.x && e.y === gameState.player.y)) takeDamage("eaten");
        }

        function checkLevelComplete() {
            if (gameState.enemies.length > 0) { showToast("–í—Ä–∞–≥–∏ –∂–∏–≤—ã!"); return; }
            if (!gameState.player.hasKey) { showToast("–ù—É–∂–µ–Ω –∫–ª—é—á!"); return; }
            showLevelComplete();
        }

        /* --- UI & GEMINI API --- */

        function getBoardString() {
            let s = "";
            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    if (gameState.player.x === x && gameState.player.y === y) s += "P";
                    else if (gameState.enemies.some(e => e.x === x && e.y === y)) s += "E";
                    else if (board[y][x] === SPRITES.HARD_WALL) s += "#";
                    else if (board[y][x] === SPRITES.SOFT_WALL) s += "W";
                    else s += ".";
                }
                s += "\n";
            }
            return s;
        }

        async function generateLevelBriefing() {
            if (!apiKey) return; // –±–µ–∑ –∫–ª—é—á–∞ –ø—Ä–æ—Å—Ç–æ –º–æ–ª—á–∏–º
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: `–ü—Ä–∏–¥—É–º–∞–π –Ω–∞–∑–≤–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è –ø–æ–¥–∑–µ–º–µ–ª—å—è ${gameState.level} –∏ –∫–æ—Ä–æ—Ç–∫—É—é –º–∏—Å—Å–∏—é (1 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ) –¥–ª—è –ë–æ–º–±–µ—Ä–º–µ–Ω–∞. –û—Ç–≤–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "–ù–∞–∑–≤–∞–Ω–∏–µ: –ú–∏—Å—Å–∏—è".` }] }] })
                });
                const d = await res.json();
                const text = d.candidates?.[0]?.content?.parts?.[0]?.text || `–£—Ä–æ–≤–µ–Ω—å ${gameState.level}`;
                showToast(`üìú ${text}`);
            } catch(e) {}
        }

        async function generateGameOverComment(win, cause) {
            if (!apiKey) { overlayAi.textContent = ""; return; }
            overlayAi.innerHTML = '<div class="spinner"></div>';
            const prompt = win
                ? "–ü–æ—Ö–≤–∞–ª–∏ –∏–≥—Ä–æ–∫–∞ –∑–∞ –ø–æ–±–µ–¥—É –≤ –ë–æ–º–±–µ—Ä–º–µ–Ω (1 —Ñ—Ä–∞–∑–∞, —Ä—É—Å—Å–∫–∏–π)."
                : `–ò–≥—Ä–æ–∫ –ø—Ä–æ–∏–≥—Ä–∞–ª (${cause}). –ü–æ—à—É—Ç–∏ –Ω–∞–¥ –Ω–∏–º (1 —Ñ—Ä–∞–∑–∞, —Ä—É—Å—Å–∫–∏–π).`;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                overlayAi.textContent = d.candidates?.[0]?.content?.parts?.[0]?.text || "";
            } catch(e) { overlayAi.textContent = ""; }
        }

        async function generateTheme() {
            if (!apiKey) { showToast("–ù–µ—Ç API –∫–ª—é—á–∞ –¥–ª—è —Ç–µ–º—ã"); return; }
            showToast("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–º—É...");
            const prompt = `JSON –¥–ª—è –∏–≥—Ä—ã. Keys: EMPTY, HARD_WALL, SOFT_WALL, PLAYER, ENEMY, BOMB, RANGE_UP, EXTRA_LIFE, KEY, DOOR, DEAD, EXTRA_BOMB. Values: 1 emoji each. Theme: Random (Candy, Horror, Space, Underwater, Matrix, Food). Only JSON.`;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                let t = d.candidates?.[0]?.content?.parts?.[0]?.text.replace(/```json/g,'').replace(/```/g,'');
                SPRITES = { ...SPRITES, ...JSON.parse(t) };
                generateMap(); 
                showToast("–¢–µ–º–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!");
            } catch(e) { showToast("–û—à–∏–±–∫–∞ —Ç–µ–º—ã"); }
        }

        async function generateAIMap() {
            if (!apiKey) { showToast("–ù–µ—Ç API –∫–ª—é—á–∞ –¥–ª—è –∫–∞—Ä—Ç—ã"); return; }
            showToast("üèóÔ∏è –ò–ò —Å—Ç—Ä–æ–∏—Ç –∫–∞—Ä—Ç—É...");
            const prompt = `Generate a 13x13 grid for a Bomberman level. Use characters: '#' for hard indestructible wall, 'T' for soft destructible tree/wall, '.' for empty space. Make it a coherent maze or pattern. Return ONLY the 13 lines of characters.`;
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                let text = d.candidates?.[0]?.content?.parts?.[0]?.text || "";
                const lines = text.trim().split('\n').filter(l => l.trim().length >= 13).slice(0, 13);
                if (lines.length === 13) {
                    initLevel(lines);
                    showToast("–ö–∞—Ä—Ç–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞!");
                } else {
                    throw new Error("Invalid format");
                }
            } catch(e) { showToast("–ò–ï –æ—à–∏–±—Å—è, —Å—Ç—Ä–æ—é –æ–±—ã—á–Ω—É—é..."); initLevel(); }
        }
        
        async function getContextualAdvice() {
            if (!apiKey) { showToast("üí° –°–æ–≤–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–Ω–µ—Ç API –∫–ª—é—á–∞)"); return; }
            showToast("üß† –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–∏—Ç—É–∞—Ü–∏—é...");
            const gridStr = getBoardString();
            const prompt = `You are a tactical advisor for Bomberman. Here is the current 13x13 grid:\n${gridStr}\nLegend: P=Player, E=Enemy, #=Hard Wall, W=Soft Wall, .=Empty.\nGive 1 short sentence of advice (in Russian) to the player based on their immediate surroundings (enemies nearby? trapped?). Keep it urgent.`;
            
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                const text = d.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) showToast("üí° " + text);
                else showToast("üí° –ë–µ–≥–∏!");
            } catch(e) {
                showToast("üí° –û—à–∏–±–∫–∞ —Å–≤—è–∑–∏ —Å —à—Ç–∞–±–æ–º");
            }
        }

        function showLevelComplete() {
            gameState.isPaused = true;

            const levelTimeSec = Math.floor((Date.now() - gameState.levelStartTime) / 1000);
            const timeBonus = Math.max(20, 200 - levelTimeSec);
            gameState.score += timeBonus;
            gameState.stats.levelsCompleted++;
            updateUI();

            overlayTitle.textContent = "–ü–û–ë–ï–î–ê!";
            overlayTitle.className = "pixel-font text-2xl text-green-400 mb-4";
            overlayMsg.innerHTML = `–£—Ä–æ–≤–µ–Ω—å –∑–∞—á–∏—â–µ–Ω –∑–∞ ${levelTimeSec} c.<br>–ë–æ–Ω—É—Å –∑–∞ —Å–∫–æ—Ä–æ—Å—Ç—å: +${timeBonus} –æ—á–∫–æ–≤.`;
            overlayBtn.textContent = "–î–ê–õ–¨–®–ï";
            overlayBtn.onclick = () => { gameState.level++; startGame(false); };
            overlay.classList.remove('hidden');
            overlay.classList.add('flex');
            generateGameOverComment(true);
        }

        /* --- –û–¢–ü–†–ê–í–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–ê –í –ë–û–¢–ê --- */
        function buildScorePayload(win, cause) {
            return {
                action: "save_score",
                game_id: GAME_ID,
                game_name: GAME_NAME,
                score: gameState.score,
                // –î–æ–ø. –ø–æ–ª—è ‚Äî –±–æ—Ç –∏—Ö –º–æ–∂–µ—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å
                level: gameState.level,
                win,
                cause,
                stats: gameState.stats,
                run_id: gameState.runId,
                timestamp: Date.now()
            };
        }

        function sendScoreToTelegram(win, cause) {
            if (!tg || !tg.sendData) {
                console.log('Not in Telegram WebApp, score not sent');
                showToast("–ß—Ç–æ–±—ã –ø–æ–ø–∞—Å—Ç—å –≤ —Ä–µ–π—Ç–∏–Ω–≥, –∏–≥—Ä–∞–π —á–µ—Ä–µ–∑ –±–æ—Ç–∞ @Games_trivia_bot");
                return;
            }
            try {
                const payload = buildScorePayload(win, cause);
                tg.sendData(JSON.stringify(payload));
                showToast("–†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ @Games_trivia_bot");
            } catch (e) {
                console.error('Telegram sendData error', e);
                showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –±–æ—Ç–∞");
            }
        }

        function showGameOver(win, cause) {
            gameState.isOver = true;
            sendScoreToTelegram(win, cause);

            overlayTitle.textContent = "GAME OVER";
            overlayTitle.className = "pixel-font text-3xl text-red-500 mb-4";
            overlayMsg.innerHTML = `–£—Ä–æ–≤–µ–Ω—å: ${gameState.level}<br>SCORE: ${gameState.score}<br>–í—Ä–∞–≥–æ–≤ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–æ: ${gameState.stats.enemiesKilled}`;
            overlayBtn.textContent = "–ó–ê–ù–û–í–û";
            overlayBtn.onclick = () => startGame(true);
            overlay.classList.remove('hidden');
            overlay.classList.add('flex');
            generateGameOverComment(false, cause);
        }

        /* --- –†–ï–ù–î–ï–† –ò UI --- */
        function render() {
            let dangerSet = new Set();
            gameState.bombs.forEach(b => {
                dangerSet.add(`${b.x},${b.y}`);
                [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d=>{
                    for(let i=1; i<=b.range; i++){
                        const tx=b.x+d.x*i, ty=b.y+d.y*i;
                        if(tx<0||tx>=GRID_SIZE||ty<0||ty>=GRID_SIZE) break;
                        if(board[ty][tx]===SPRITES.HARD_WALL) break;
                        dangerSet.add(`${tx},${ty}`);
                        if(board[ty][tx]===SPRITES.SOFT_WALL) break;
                    }
                });
            });

            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    const cell = document.getElementById(`c-${x}-${y}`);
                    if(!cell) continue;
                    
                    let content = board[y][x];
                    let className = 'cell';
                    if(dangerSet.has(`${x},${y}`)) className += ' danger-zone';

                    const bomb = gameState.bombs.find(b=>b.x===x && b.y===y);
                    const enemy = gameState.enemies.find(e=>e.x===x && e.y===y);
                    const isPlayer = (gameState.player.x===x && gameState.player.y===y);

                    if(isPlayer) { content = gameState.player.lives>0 ? SPRITES.PLAYER : SPRITES.DEAD; className += ' player'; }
                    else if(enemy) { content = SPRITES.ENEMY; className += ' enemy'; }
                    else if(bomb) { content = SPRITES.BOMB; className += ' bomb'; }
                    else if([SPRITES.KEY, SPRITES.DOOR, SPRITES.RANGE_UP, SPRITES.EXTRA_LIFE, SPRITES.EXTRA_BOMB].includes(content)) className += ' item';

                    if (cell.textContent !== content) cell.textContent = content;
                    if (cell.className !== className) cell.className = className;
                }
            }
        }

        function updateUI() {
            levelEl.textContent = gameState.level;
            livesEl.textContent = gameState.player.lives;
            keyEl.textContent = gameState.player.hasKey ? "‚úÖ" : "‚ùå";
            if (bombsEl) bombsEl.textContent = gameState.player.maxBombs;
            if (scoreEl) scoreEl.textContent = gameState.score;
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            document.getElementById('toast-msg').textContent = msg;
            t.classList.remove('opacity-0', 'pointer-events-none');
            setTimeout(() => t.classList.add('opacity-0', 'pointer-events-none'), 3000);
        }

        /* --- LISTENERS --- */
        document.querySelectorAll('.btn-control').forEach(btn => {
            const key = btn.dataset.key;
            const press = (e) => { e.preventDefault(); setInput(key, true); btn.classList.add('pressed'); if(navigator.vibrate) navigator.vibrate(5); };
            const release = (e) => { e.preventDefault(); setInput(key, false); btn.classList.remove('pressed'); };
            
            btn.addEventListener('touchstart', press, {passive: false});
            btn.addEventListener('touchend', release);
            btn.addEventListener('mousedown', press);
            btn.addEventListener('mouseup', release);
            btn.addEventListener('mouseleave', release);
        });
        
        window.addEventListener('touchend', () => { /* Global release safety */ });
        
        window.addEventListener('keydown', e => {
            const m = {'ArrowUp':'ArrowUp','w':'ArrowUp','ArrowDown':'ArrowDown','s':'ArrowDown','ArrowLeft':'ArrowLeft','a':'ArrowLeft','ArrowRight':'ArrowRight','d':'ArrowRight',' ':'Space','Enter':'Space'};
            if(m[e.key] && !e.repeat) setInput(m[e.key], true);
        });
        window.addEventListener('keyup', e => {
            const m = {'ArrowUp':'ArrowUp','w':'ArrowUp','ArrowDown':'ArrowDown','s':'ArrowDown','ArrowLeft':'ArrowLeft','a':'ArrowLeft','ArrowRight':'ArrowRight','d':'ArrowRight',' ':'Space','Enter':'Space'};
            if(m[e.key]) setInput(m[e.key], false);
        });

        document.getElementById('ai-btn').addEventListener('click', getContextualAdvice);
        document.getElementById('ai-theme-btn').addEventListener('click', generateTheme);
        document.getElementById('ai-map-btn').addEventListener('click', generateAIMap);

        // –ï—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω–æ –Ω–µ –∏–∑ Telegram ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø—Ä–æ —Ä–µ–π—Ç–∏–Ω–≥
        if (!tg) {
            setTimeout(() => {
                showToast("–î–ª—è —É—á–∞—Å—Ç–∏—è –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ –æ—Ç–∫—Ä–æ–π –∏–≥—Ä—É —á–µ—Ä–µ–∑ –±–æ—Ç–∞ @Games_trivia_bot");
            }, 1000);
        }

        // START
        startGame(true);
    </script>
</body>
</html>
